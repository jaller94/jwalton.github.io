---
title: "Custom Validators in swagger-node-runner (Swagger on Node.js part 2)"
tags:
- javascript
- babel
- es6
- modules
- swagger
- OpenAPI
- validation
---

This is an article about using custom validators in
[swagger-node-runner](https://github.com/theganyo/swagger-node-runner)
on Node.js.  In [part one](/2018/03/15/swagger-nodejs1/) of this series,
we set up a project with a simple API for retrieving objects from a MongoDB
database.

<!--more-->

In our API, to GET a user you need to pass in a required "id" paramater.
This is of type "string", and of format "ObjectId".  swagger-node-runner will
validate that the parameter is a string (although just about anything will pass
validation for string), but swagger-node-runner doesn't know anything about
"ObjectId" - it's not part of the OpenAPI 2.0 spec, it's just a format we made
up.  We'd like to make it so swagger-node-runner automatically validates that
ObjectId is a 24 character hex string, to conform with MongoDB ObjectIds.

swagger-node-runner relies on the [sway](https://github.com/apigee-127/sway)
library to do validation, which in turn relies on
[z-schema](https://github.com/zaggino/z-schema).  The latest (but as yet
unpublished) version of sway has a `registerFormat(formatName, validator)`,
where `validator` is a `fn(str)` that returns true if the value is valid
or false otherwise.  `validator` an also be a `fn(str, callback)` if you need
to use an async function.  (See https://github.com/apigee-127/sway/issues/74.)
Note that, when the next sway is release, you'll be able to access this function
via `swaggerRunner.api.registerFormat(...)`.

Since this function doesn't exist yet in the published version of sway, you
have two options for custom validation.

### The Hacky Way

The first is the hacky way; `npm install z-schema@^3.16.1` to install the same
version of z-schema that `sway@1.0.0` uses.  Since z-schema uses a global pool
of format IDs, you can do:

```js
import Zschema from 'z-schema';
const OBJECTID_REGEX = /^[0-9a-fA-F]{24}$/;
Zschema.registerFormat('ObjectId', str => OBJECTID_REGEX.test(str));
```

And now, if you try to visit
[http://localhost:10010/api/v1/user?id=54f0be26ae8aba260b8f6db7](http://localhost:10010/api/v1/user?id=54f0be26ae8aba260b8f6db7)
in our sample app, you'll get back a User object, but if you try to visit
[http://localhost:10010/api/v1/user?id=foo](http://localhost:10010/api/v1/user?id=foo),
you'll get back a monster huge blob of JSON:

```json
{
    "message":"Validation errors",
    "errors":[{
        "code":"INVALID_REQUEST_PARAMETER",
        "errors":[{
            "code":"INVALID_FORMAT",
            "params":["ObjectId","foo"],
            "message":"Object didn't pass validation for format ObjectId: foo",
            "path":[],
            "description":"The ID of the user to get."
        }],
        "in":"query",
        "message":"Invalid parameter (id): Value failed JSON Schema validation",
        "name":"id",
        "path":["paths","/user","get","parameters","0"]
    }]
}
```

This is hacky in many ways; if you upgrade swagger-node-runner, and it
upgrades sway, you'll need to make sure you upgrade z-schema; if you have two
different version os z-schema in the mix, you might register your formats
against one of them, and the other one won't see these changes.

Even when the new sway comes out, though, this is still modifying essentially
a global variable, polluting z-schema with your custom types.

### The Custom Fitting Way

The second way to do this is to write a custom bagpipe fitting.  This is,
arguably, the better way.  We want a fitting that will generate errors that
look like the errors generated by sway.

The example here is really a demo to show off writing custom bagpipe fittings
with swagger-node-runner.  To make a "production quality" version of this,
you'd have to do a lot more work, as you could be passed complex objects via
`context.input`, in which case you'd need to walk the tree of these objects
and do validation at every level.  You can see a more complex (but likely
still incomplete) version of this
[here](https://github.com/jwalton/node-swagger-template/blob/master/src/swagger/fittings/custom_validators.js).

To write a custom fitting, first we add our fitting into the
swagger-node-runner config:

```js
        swagger_controllers: [
            {onError: 'json_error_handler'},
            'cors',
            'swagger_params_parser',
            // Custom fitting, found in /src/swagger/fittings/custom_validators.js
            'custom_validators',
            'swagger_security',
            '_swagger_validate',
            'express_compatibility',
            '_router'
        ],
```

Then we need to create a source file for this fitting.  In our project, this
goes in /src/swagger/fittings (because this is the `fittingsDirs` we passed
to swagger-node-runner in the config).

```js
// src/swagger/fittings/custom_validators.js

const validators = {
    "ObjectId": str => OBJECTID_REGEX.test(str)
};

module.exports = function custom_validators(fittingDef, bagpipes) {
    return function myFitting(context, cb) {
        const errors = {};

        var input = context.input;

        // ***************************************************************
        // This is a HUGELY simplified example.  The real version would
        // have to deal with more complicated objects being passed in,
        // and would have to walk the schema of those objects looking
        // for values to validate.
        // ***************************************************************
        for(const param of Object.keys(input)) {
            const {definition} = input[param].parameterObject;
            const validator = validators[definition.format];
            if(validator) {
                if(!validator(input[param].value)) {
                    results.errors.push({
                        code: 'INVALID_REQUEST_PARAMETER',
                        errors: [{
                            code: 'REQUIRED',
                            message: `Object didn't pass validation for format ${definition.format}: ${value}`,
                        }],
                        in: definition.in,
                        message: `Invalid parameter (${param}): Value failed JSON Schema validation`,
                    });
                }
            }
        }

        if(errors.length) {
            const err = new Error('Validation errors');
            err.statusCode = 400;
            err.errors = errors;
            cd(err);
            return;
        }

        cb(null);
    };
};
```
